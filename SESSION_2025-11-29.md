# Development Session - November 29, 2025

## Overview
This session focused on implementing selective version history, improving UI/UX for version management, adding loading states, fixing bugs, and implementing a replace resume confirmation workflow.

---

## 1. Base Resume ID Bug Fix

### Issue
User authentication was not returning `base_resume_id`, preventing proper navigation between landing page and dashboard.

### Changes Made

**File: `backend/models/user.py`** (lines 41-44)
```python
@property
def base_resume_id(self):
    """Get base resume ID from relationship"""
    return self.base_resume.id if self.base_resume else None
```

**File: `backend/schemas/user.py`** (line 31)
```python
class UserResponse(BaseModel):
    # ... existing fields ...
    base_resume_id: Optional[int] = None  # ID of user's base resume (null if not uploaded)
```

### Impact
- Frontend can now check if user has uploaded a base resume
- Landing page shows correct button ("Upload Resume" vs "Go to Dashboard")
- Navbar conditionally shows "Projects" button only when user has base resume

---

## 2. Version History UI Improvements

### Feature: Hide Version Bar for Single Version

**Issue**: Version tabs were showing even when only V0 existed, causing unnecessary UI clutter.

**Files Modified:**
- `frontend/src/components/project-editor/ProjectsSection.jsx` (line 67)
- `frontend/src/components/project-editor/ExperienceSection.jsx` (line 67)
- `frontend/src/components/project-editor/SkillsSection.jsx` (line 67)
- `frontend/src/components/project-editor/ProfessionalSummarySection.jsx` (line 66)

**Change:**
```javascript
// OLD: Show tabs if currentVersion > 0 OR if any history exists
const showVersionTabs = currentVersion > 0 || (hasHistory && versionNumbers.length > 0);

// NEW: Only show if multiple versions exist
const showVersionTabs = hasHistory && versionNumbers.length > 1;
```

### Impact
- Version bar only appears when there are actually multiple versions (V0 + V1+)
- Cleaner UI for sections that haven't been modified yet

---

## 3. Hyperlink Font Fix in DOCX Generation

### Issue
Header links (LinkedIn, GitHub, etc.) were using default font instead of Calibri.

**File: `backend/services/docx_generation_service.py`** (lines 161-165)

**Change:**
```python
# Set font name to Calibri
rFonts = OxmlElement('w:rFonts')
rFonts.set(qn('w:ascii'), 'Calibri')
rFonts.set(qn('w:hAnsi'), 'Calibri')
rPr.append(rFonts)
```

### Impact
- All hyperlinks in resume header now use Calibri font
- Consistent typography throughout the document

---

## 4. Version Restoration Loading Spinner

### Issue
"Make This Current" button had lag with no visual feedback, users could click multiple times.

### Changes Made

**File: `frontend/src/pages/ProjectEditor.jsx`**

**Added State** (line 77):
```javascript
const [restoringVersion, setRestoringVersion] = useState(false);
```

**Updated Handler** (lines 584, 610):
```javascript
const handleRestoreVersion = async (sectionName, versionNumber) => {
  setRestoringVersion(true);  // Show loading
  try {
    // ... API call ...
  } finally {
    setRestoringVersion(false);  // Hide loading
  }
};
```

**Passed to Sections** (lines 997, 1015, 1033, 1068):
```javascript
<ProfessionalSummarySection
  // ... other props ...
  restoringVersion={restoringVersion}
/>
```

**Files Modified (Button Updates):**
- `frontend/src/components/project-editor/ProjectsSection.jsx` (lines 367-378)
- `frontend/src/components/project-editor/ExperienceSection.jsx` (lines 513-524)
- `frontend/src/components/project-editor/SkillsSection.jsx` (lines 305-316)
- `frontend/src/components/project-editor/ProfessionalSummarySection.jsx` (lines 191-202)

**Button Changes:**
```javascript
<Button
  onClick={handleRestoreVersion}
  disabled={restoringVersion}
  startIcon={restoringVersion ? <CircularProgress size={16} sx={{ color: '#000' }} /> : null}
  sx={{
    // ... existing styles ...
    '&:disabled': { bgcolor: colorPalette.secondary.mediumGreen, color: '#000' }
  }}
>
  {restoringVersion ? 'Restoring...' : 'Make This Current'}
</Button>
```

### Impact
- Visual feedback during version restoration
- Button disabled during operation prevents duplicate requests
- Better UX, no more confusion about lag

---

## 5. Auto-Switch to Current Version When Editing

### Issue
Users could click edit while viewing an old version (V0), which would edit the wrong version.

### Changes Made

**File: `frontend/src/pages/ProjectEditor.jsx`** (lines 404-415)

**Handler Update:**
```javascript
const handleStartEditingSection = (sectionKey) => {
  // ... existing code ...

  // If user is viewing an old version, switch to current version before editing
  const sectionsWithVersioning = ['professional_summary', 'experience', 'projects', 'skills'];
  if (sectionsWithVersioning.includes(sectionKey)) {
    const currentVersionNum = project?.current_versions?.[sectionKey] || 0;
    const viewingVersionNum = viewingVersions[sectionKey];

    if (viewingVersionNum !== currentVersionNum) {
      // Switch to current version
      setViewingVersions(prev => ({ ...prev, [sectionKey]: currentVersionNum }));
      console.log(`üîÑ Switched from V${viewingVersionNum} to current V${currentVersionNum} before editing`);
    }
  }

  setEditingSection(sectionKey);
  // ... rest of code ...
};
```

**Section Components** (All 4 section files, added useEffect):
```javascript
// Listen for external version changes (e.g., when switching to edit mode)
useEffect(() => {
  // This effect runs when isEditing becomes true
  if (isEditing && viewingVersion !== currentVersion) {
    setViewingVersion(currentVersion);
    if (onViewingVersionChange) {
      onViewingVersionChange(currentVersion);
    }
  }
}, [isEditing]); // Switch to current version when entering edit mode
```

**Files Modified:**
- `frontend/src/components/project-editor/ProfessionalSummarySection.jsx` (lines 31-40)
- `frontend/src/components/project-editor/ExperienceSection.jsx` (lines 33-42)
- `frontend/src/components/project-editor/ProjectsSection.jsx` (lines 33-42)
- `frontend/src/components/project-editor/SkillsSection.jsx` (lines 33-42)

### Impact
- Users always edit the current/active version
- Version tab automatically switches when entering edit mode
- Prevents accidental editing of old versions

---

## 6. Skills Section Validation Enhancement

### Issue
Users could save skill categories with empty names or no skills.

**File: `frontend/src/pages/ProjectEditor.jsx`** (lines 512-531)

**Old Validation:**
```javascript
// Only checked for skills, allowed empty category names
if (!hasValidSkill) {
  toast.error(`Category "${category}" cannot be empty...`);
  return;
}
```

**New Validation:**
```javascript
// Check if category name is empty
if (!category.trim()) {
  toast.error('Category name cannot be empty. Please provide a name or remove the category.');
  return; // Don't save
}

// Check if category has at least one skill
const hasValidSkill = skills.some(s => s && s.trim().length > 0);
if (!hasValidSkill) {
  toast.error(`Category "${category}" must have at least one skill. Please add a skill or remove the category.`);
  return; // Don't save
}
```

### Impact
- Users cannot save empty category names
- Users cannot save categories without skills
- Both validations must pass before save succeeds
- Better data quality

---

## 7. Selective Version History Implementation

### Issue
When editing ONE section, ALL sections got new version numbers, creating unnecessary versions.

### Solution
Compare old vs new data and only create versions for sections that actually changed.

**File: `backend/routers/projects.py`**

**Tailoring Endpoint** (lines 498-534):
```python
for section in sections_to_track:
    if section in current_resume_json and section in new_resume_json:
        # Check if section actually changed
        section_changed = current_resume_json[section] != new_resume_json[section]

        if section_changed:
            logger.info(f"Section '{section}' changed - creating new version")
            current_version_num = project_to_update.current_versions.get(section, 0)
            new_version_num = current_version_num + 1
            project_to_update.version_history[section][str(new_version_num)] = new_resume_json[section]
            project_to_update.current_versions[section] = new_version_num
        else:
            logger.info(f"Section '{section}' unchanged - keeping version {project_to_update.current_versions.get(section, 0)}")
```

**Edit-Resume Endpoint** (lines 761-848):
- Added complete version_history system (was previously missing)
- Implemented same selective versioning logic as tailoring

### Impact
- Only sections that actually change get new versions
- Reduces version clutter
- More accurate version tracking
- Users can see exactly which sections were modified

---

## 8. Replace Resume Confirmation Workflow

### Issue
Replacing resume didn't clear version history, causing confusion with old versions persisting.

### Solution
Added confirmation dialog that warns user and clears all history before replacing.

### Frontend Changes

**File: `frontend/src/pages/ProjectEditor.jsx`**

**Import** (line 21):
```javascript
import ConfirmDialog from '../components/common/ConfirmDialog';
```

**State** (line 82):
```javascript
const [showReplaceConfirmDialog, setShowReplaceConfirmDialog] = useState(false);
```

**Handler Function** (lines 636-658):
```javascript
// Handle replace resume with confirmation
const handleReplaceConfirm = async () => {
  try {
    // Clear version history from backend
    await api.post(`/api/projects/${projectId}/clear-version-history`);

    // Reset local viewing versions to 0
    setViewingVersions({
      professional_summary: 0,
      experience: 0,
      projects: 0,
      skills: 0,
    });

    // Close dialog and trigger file input
    setShowReplaceConfirmDialog(false);
    fileInputRef.current?.click();
  } catch (error) {
    console.error('Failed to clear version history:', error);
    toast.error('Failed to prepare for replacement. Please try again.');
    setShowReplaceConfirmDialog(false);
  }
};
```

**Button Handler Update** (line 1275):
```javascript
// OLD: onReplaceClick={() => fileInputRef.current?.click()}
// NEW:
onReplaceClick={() => setShowReplaceConfirmDialog(true)}
```

**Dialog Component** (lines 1375-1385):
```javascript
<ConfirmDialog
  open={showReplaceConfirmDialog}
  onClose={() => setShowReplaceConfirmDialog(false)}
  onConfirm={handleReplaceConfirm}
  title="Replace Resume"
  message="Replacing your resume will clear all version history for this project. This will make it a fresh project with no previous versions. Are you sure you want to continue?"
  confirmText="Yes, Replace"
  cancelText="Cancel"
  confirmColor="warning"
/>
```

### Backend Changes

**File: `backend/routers/projects.py`** (lines 1091-1146)

**New Endpoint:**
```python
@router.post("/{project_id}/clear-version-history", response_model=ProjectResponse)
async def clear_version_history(
    project_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Clear all version history for a project, resetting it to a fresh state.
    This is typically called before replacing the resume to avoid confusion.

    This endpoint:
    1. Clears version_history dict
    2. Resets current_versions to all 0s
    3. Clears tailoring_history
    4. Returns the updated project
    """
    # Get project
    project = db.query(Project).filter(
        Project.id == project_id,
        Project.user_id == current_user.id
    ).first()

    if not project:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Project not found"
        )

    # Clear version history
    project.version_history = {}
    project.current_versions = {
        "professional_summary": 0,
        "experience": 0,
        "projects": 0,
        "skills": 0
    }

    # Clear tailoring history
    project.tailoring_history = []

    # Mark as modified for SQLAlchemy
    from sqlalchemy.orm.attributes import flag_modified
    flag_modified(project, 'version_history')
    flag_modified(project, 'current_versions')
    flag_modified(project, 'tailoring_history')

    # Mark as updated
    from sqlalchemy import func
    project.updated_at = func.now()

    db.commit()
    db.refresh(project)

    logger.info(f"Cleared version history for project {project_id}")

    return project
```

### Impact
- Users are warned before replacing resume
- All version history is cleared on confirmation
- Project becomes "fresh" with no confusing old versions
- Prevents version clutter after resume replacement
- Clear user workflow: Warning ‚Üí Confirm ‚Üí Clear History ‚Üí Upload

---

## Files Modified Summary

### Frontend Files
1. `frontend/src/pages/ProjectEditor.jsx`
   - Base resume navigation logic
   - Version restoration loading state
   - Auto-switch to current version on edit
   - Skills validation enhancement
   - Replace confirmation dialog

2. `frontend/src/components/project-editor/ProjectsSection.jsx`
   - Hide version bar for single version
   - Loading spinner on restore button
   - Auto-switch to current on edit

3. `frontend/src/components/project-editor/ExperienceSection.jsx`
   - Hide version bar for single version
   - Loading spinner on restore button
   - Auto-switch to current on edit

4. `frontend/src/components/project-editor/SkillsSection.jsx`
   - Hide version bar for single version
   - Loading spinner on restore button
   - Auto-switch to current on edit

5. `frontend/src/components/project-editor/ProfessionalSummarySection.jsx`
   - Hide version bar for single version
   - Loading spinner on restore button
   - Auto-switch to current on edit

6. `frontend/src/pages/Landing.jsx`
   - Conditional button text/navigation based on base_resume_id

7. `frontend/src/components/common/Navbar.jsx`
   - Conditional Projects button visibility

### Backend Files
1. `backend/models/user.py`
   - Added base_resume_id property

2. `backend/schemas/user.py`
   - Added base_resume_id field to UserResponse

3. `backend/services/docx_generation_service.py`
   - Fixed hyperlink font to Calibri

4. `backend/routers/projects.py`
   - Selective version history for tailoring
   - Selective version history for edit-resume
   - New clear-version-history endpoint

---

## Testing Checklist

### User Authentication
- [x] User with base resume sees "Go to Dashboard" on landing page
- [x] User without base resume sees "Upload Resume" on landing page
- [x] Projects button hidden in navbar when no base resume
- [x] Projects button visible when base resume exists

### Version History
- [x] Version bar hidden when only V0 exists
- [x] Version bar shows when V0 and V1+ exist
- [x] Only modified sections get new versions
- [x] Unchanged sections keep current version number

### Version Restoration
- [x] "Make This Current" shows loading spinner
- [x] Button disabled during restoration
- [x] Button text changes to "Restoring..."
- [x] Cannot click multiple times during operation

### Edit Mode
- [x] Editing V0 while V1 is current auto-switches to V1
- [x] Version tab visually switches when entering edit mode
- [x] Edit always works on current version

### Skills Validation
- [x] Cannot save empty category name
- [x] Cannot save category without skills
- [x] Both validations enforced before save

### Replace Resume
- [x] Replace button shows confirmation dialog
- [x] Dialog explains history will be cleared
- [x] Cancel closes dialog, no changes
- [x] Confirm clears all version history
- [x] Confirm clears tailoring history
- [x] Confirm resets current_versions to 0
- [x] File picker opens after history cleared
- [x] Project becomes fresh with no versions

### DOCX Generation
- [x] Header links use Calibri font
- [x] Links match other header text styling

---

## Known Issues / Future Improvements

None identified during this session. All implemented features working as expected.

---

## Session Statistics

- **Files Modified**: 12
- **Lines Added**: ~500
- **Lines Modified**: ~200
- **New Features**: 4
- **Bug Fixes**: 3
- **UX Improvements**: 6
- **Backend Endpoints Added**: 1

---

## Notes for Future Development

1. **Version History**: The selective versioning system is now fully implemented. Future sections added should follow the same pattern.

2. **Replace Resume**: Consider adding ability to download version history before clearing (export feature).

3. **Skills Section**: The validation pattern used here can be applied to other sections if needed.

4. **Loading States**: All async operations should have loading states like the restore version implementation.

5. **Confirmation Dialogs**: Use ConfirmDialog for all destructive operations.

---

## 9. Custom Email Validation in Auth Forms

### Issue
- Browser's native email validation (`type="email"`) showed verbose error messages like "Please include @ in the email address"
- Native validation was too lenient and allowed incomplete emails like "geminp12@gmail" (missing TLD)
- User wanted simple "Invalid email" message
- Needed to enforce strict email format with required TLD

### Solution
Implemented custom email validation in both LoginForm and SignupForm with real-time validation feedback.

### Frontend Changes

**Email Validation Regex:**
```javascript
const validateEmail = (email) => {
  // Regex that requires @ and a TLD (e.g., .com, .org, .net)
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};
```

#### File: `frontend/src/components/auth/LoginForm.jsx`

**Added State** (line 29):
```javascript
const [emailError, setEmailError] = useState('');
```

**Updated handleChange** (lines 35-57):
```javascript
const handleChange = (e) => {
  const { name, value } = e.target;

  setFormData({
    ...formData,
    [name]: value,
  });

  // Validate email on change
  if (name === 'email') {
    if (value && !validateEmail(value)) {
      setEmailError('Invalid email');
    } else {
      setEmailError('');
    }
  }
};
```

**Updated handleSubmit** (lines 59-80):
```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  setError('');
  setLoading(true);

  // Validate email before submitting
  if (!validateEmail(formData.email)) {
    setEmailError('Invalid email');
    setLoading(false);
    return;
  }

  // ... rest of submit logic
};
```

**Updated TextField** (lines 159-172):
```javascript
<TextField
  fullWidth
  label="Email"
  name="email"
  type="text"  // Changed from "email" to avoid browser validation
  value={formData.email}
  onChange={handleChange}
  margin="normal"
  required
  autoComplete="email"
  autoFocus
  error={!!emailError}  // Show error state
  helperText={emailError}  // Show "Invalid email" message
/>
```

#### File: `frontend/src/components/auth/SignupForm.jsx`

**Added States** (lines 31-33):
```javascript
const [emailError, setEmailError] = useState('');
const [passwordError, setPasswordError] = useState('');
const [confirmPasswordError, setConfirmPasswordError] = useState('');
```

**Updated handleChange** (lines 39-86):
```javascript
const handleChange = (e) => {
  const { name, value } = e.target;

  setFormData({
    ...formData,
    [name]: value,
  });

  // Validate email on change
  if (name === 'email') {
    if (value && !validateEmail(value)) {
      setEmailError('Invalid email');
    } else {
      setEmailError('');
    }
  }

  // Validate password on change
  if (name === 'password') {
    if (value && value.length < 8) {
      setPasswordError('Password must be at least 8 characters long');
    } else {
      setPasswordError('');
    }

    // Also check confirm password match if it's filled
    if (formData.confirmPassword && value !== formData.confirmPassword) {
      setConfirmPasswordError('Passwords do not match');
    } else {
      setConfirmPasswordError('');
    }
  }

  // Validate confirm password on change
  if (name === 'confirmPassword') {
    if (value && value !== formData.password) {
      setConfirmPasswordError('Passwords do not match');
    } else {
      setConfirmPasswordError('');
    }
  }
};
```

**Updated handleSubmit** (lines 88-110):
```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  setError('');

  // Validate email
  if (!validateEmail(formData.email)) {
    setEmailError('Invalid email');
    return;
  }

  // Validate password
  if (formData.password.length < 8) {
    setPasswordError('Password must be at least 8 characters long');
    return;
  }

  // Validate password match
  if (formData.password !== formData.confirmPassword) {
    setConfirmPasswordError('Passwords do not match');
    return;
  }

  setLoading(true);
  // ... rest of submit logic
};
```

**Updated TextFields** (lines 215-253):
```javascript
{/* Email Field */}
<TextField
  fullWidth
  label="Email"
  name="email"
  type="text"  // Changed from "email"
  value={formData.email}
  onChange={handleChange}
  margin="normal"
  required
  autoComplete="email"
  error={!!emailError}
  helperText={emailError}
/>

{/* Password Field */}
<TextField
  fullWidth
  label="Password"
  name="password"
  type="password"
  value={formData.password}
  onChange={handleChange}
  margin="normal"
  required
  autoComplete="new-password"
  error={!!passwordError}
  helperText={passwordError || "Minimum 8 characters"}
/>

{/* Confirm Password Field */}
<TextField
  fullWidth
  label="Confirm Password"
  name="confirmPassword"
  type="password"
  value={formData.confirmPassword}
  onChange={handleChange}
  margin="normal"
  required
  autoComplete="new-password"
  error={!!confirmPasswordError}
  helperText={confirmPasswordError}
/>
```

### Impact
- Email validation now rejects incomplete emails like "user@domain" (no TLD)
- Shows simple "Invalid email" message instead of verbose browser messages
- Real-time validation as user types
- Password validation enhanced with real-time feedback
- Confirm password validation shows immediate mismatch errors
- Better UX with clear, concise error messages
- All validation happens before form submission

### Validation Rules Enforced
1. **Email**: Must contain @ and a TLD (.com, .org, etc.)
2. **Password**: Minimum 8 characters
3. **Confirm Password**: Must match password field
4. **Full Name**: Required (native HTML validation)

---

## 10. Email Verification Enforcement - Complete Security Overhaul

### Issue
**CRITICAL SECURITY FLAW**: Users could access the entire application without verifying their email.

**Problems Identified:**
1. Registration auto-logged users in immediately (unverified)
2. Login allowed unverified users to access protected routes
3. ProtectedRoute only checked if user exists, not if verified
4. Backend middleware didn't verify email status
5. Users could navigate through app freely without verification
6. Google and password auth could create duplicate emails

### Solution
Implemented multi-layer email verification enforcement across frontend and backend.

---

### Backend Changes

#### 1. New Email Verification Middleware

**File: `backend/middleware/auth_middleware.py`** (lines 53-74)

**Added New Dependency:**
```python
async def get_current_verified_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """
    Dependency to get current authenticated AND email-verified user.
    Use this for all protected routes that require email verification.

    Google users are automatically verified, so they will pass this check.
    """
    # First get the authenticated user
    user = await get_current_user(credentials, db)

    # Check if email is verified
    if not user.email_verified:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Email not verified. Please verify your email to access this resource.",
            headers={"X-Email-Verified": "false"},
        )

    return user
```

**Purpose:**
- Replace `get_current_user` with this on all protected routes
- Blocks unverified users at API level
- Google users automatically pass (they're pre-verified)

---

#### 2. Login Endpoint - Generate New Code for Unverified Users

**File: `backend/routers/auth.py`** (lines 32-68)

**Updated Login Logic:**
```python
@router.post("/login", response_model=Token)
async def login(credentials: UserLogin, db: Session = Depends(get_db)):
    """Login with email and password"""
    user = AuthService.authenticate_user(db, credentials)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password"
        )

    # Check if email is verified
    if not user.email_verified:
        # Generate NEW verification code for this login attempt
        verification_code = email_service.generate_verification_code()
        verification_link_token = email_service.generate_verification_link_token()
        verification_expiry = email_service.get_verification_expiry()

        # Update user with new tokens
        user.verification_token = verification_code
        user.verification_token_expires = verification_expiry
        user.verification_link_token = verification_link_token
        db.commit()

        # Send new verification email
        email_service.send_verification_email(
            email=user.email,
            full_name=user.full_name,
            verification_code=verification_code,
            verification_link_token=verification_link_token
        )

        # Return token response but frontend will check email_verified flag
        # and redirect to verification page instead of logging in
        return AuthService.create_token_response(user)

    return AuthService.create_token_response(user)
```

**Key Features:**
- Generates FRESH verification code on every unverified login attempt
- Sends new email with code
- Returns response with `email_verified: false` flag
- Frontend detects flag and redirects to verification page

---

#### 3. Unique Email Enforcement Across All Auth Methods

**File: `backend/services/auth_service.py`** (lines 76-139)

**Updated Google Authentication:**
```python
@staticmethod
def authenticate_google_user(db: Session, id_token_str: str) -> User:
    """
    Authenticate or create user with Google OAuth.
    Enforces unique email - one email can only have ONE user account.
    """
    try:
        # ... Google token verification ...

        # FIRST: Check if user exists by email (UNIQUE email enforcement)
        user = db.query(User).filter(User.email == email).first()

        if user:
            # User exists with this email
            if user.google_id is None:
                # User registered with password, now linking Google account
                user.google_id = google_id
                user.profile_picture_url = picture
                user.email_verified = True  # Google users are pre-verified
                # Clear any pending verification tokens since now verified
                user.verification_token = None
                user.verification_token_expires = None
                user.verification_link_token = None
            elif user.google_id != google_id:
                # Email exists but with different Google ID - security rejection
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="This email is already associated with a different Google account"
                )
            # else: same google_id, just logging in normally
        else:
            # No user with this email - create new user
            user = User(
                email=email,
                google_id=google_id,
                full_name=full_name,
                profile_picture_url=picture,
                email_verified=True  # Google users are pre-verified
            )
            db.add(user)

        # Update last login
        user.last_login = datetime.utcnow()
        db.commit()
        db.refresh(user)
        return user

    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Invalid Google token: {str(e)}"
        )
```

**Unique Email Enforcement:**
- ONE email = ONE user account (regardless of auth method)
- If password user signs in with Google ‚Üí links accounts, auto-verifies
- If email exists with different Google ID ‚Üí rejects (security)
- Clears verification tokens when Google linking happens

---

#### 4. Protected Routes Updated to Require Verification

**Files Modified:**
- `backend/routers/users.py` - All 3 endpoints
- `backend/routers/projects.py` - All 15+ endpoints
- `backend/routers/resumes.py` - All 7 endpoints

**Change:**
```python
# OLD
current_user: User = Depends(get_current_user)

# NEW
current_user: User = Depends(get_current_verified_user)
```

**Impact:**
- All protected API endpoints now require email verification
- Unverified users get 403 Forbidden response
- Google users pass automatically (pre-verified)

---

### Frontend Changes

#### 1. AuthContext - Don't Login Unverified Users

**File: `frontend/src/context/AuthContext.jsx`** (lines 27-48)

**Updated Login Function:**
```javascript
const login = async (credentials) => {
  const data = await authService.login(credentials);

  // Only set user if email is verified
  if (data.user && data.user.email_verified) {
    setUser(data.user);
  } else {
    // Don't set user for unverified - they need to verify first
    setUser(null);
  }

  return data;
};

const register = async (userData) => {
  const data = await authService.register(userData);

  // Don't auto-login on registration - user needs to verify email first
  setUser(null);

  return data;
};
```

**Key Changes:**
- Login only sets user if `email_verified === true`
- Register NEVER sets user (always requires verification)
- Unverified users remain logged out

---

#### 2. AuthService - Don't Store Tokens for Unverified

**File: `frontend/src/services/authService.js`** (lines 4-24)

**Updated Functions:**
```javascript
// Register new user
register: async (userData) => {
  const response = await api.post('/api/auth/register', userData);
  // DON'T store tokens for unverified users
  // They need to verify email first before being logged in
  return response.data;
},

// Login with email and password
login: async (credentials) => {
  const response = await api.post('/api/auth/login', credentials);

  // Only store tokens if user is verified
  if (response.data.access_token && response.data.user?.email_verified) {
    localStorage.setItem('access_token', response.data.access_token);
    localStorage.setItem('user', JSON.stringify(response.data.user));
  }
  // If unverified, don't store anything - user will be redirected to verification

  return response.data;
},
```

**Impact:**
- Tokens only stored for verified users
- Unverified users have no tokens in localStorage
- Clean separation between verified/unverified state

---

#### 3. LoginForm - Redirect Unverified to Verification

**File: `frontend/src/components/auth/LoginForm.jsx`** (lines 59-89)

**Updated Submit Handler:**
```javascript
const handleSubmit = async (e) => {
  e.preventDefault();
  setError('');
  setLoading(true);

  // Validate email before submitting
  if (!validateEmail(formData.email)) {
    setEmailError('Invalid email');
    setLoading(false);
    return;
  }

  try {
    const response = await login(formData);

    // Check if email is verified
    if (response.user && !response.user.email_verified) {
      // User is not verified - redirect to verification page
      toast.info('Please verify your email to continue. A new verification code has been sent.');
      navigate('/verify-email', { state: { email: formData.email } });
    } else {
      // User is verified - proceed to dashboard
      toast.success('Welcome back!');
      navigate('/dashboard');
    }
  } catch (err) {
    setError(err.response?.data?.detail || 'Failed to login. Please check your credentials.');
  } finally {
    setLoading(false);
  }
};
```

**Flow:**
1. User logs in with unverified email
2. Backend generates NEW code and sends email
3. Frontend detects `email_verified: false`
4. Shows toast: "A new verification code has been sent"
5. Redirects to `/verify-email` with email pre-filled
6. User enters code from fresh email

---

#### 4. ProtectedRoute - Check Email Verification

**File: `frontend/src/components/common/ProtectedRoute.jsx`** (lines 5-33)

**Updated Protection Logic:**
```javascript
const ProtectedRoute = ({ children }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
        <CircularProgress />
      </Box>
    );
  }

  // Not logged in - redirect to landing page
  if (!user) {
    return <Navigate to="/" replace />;
  }

  // Logged in but email not verified - redirect to verification page
  if (!user.email_verified) {
    return <Navigate to="/verify-email" state={{ email: user.email }} replace />;
  }

  // User is logged in AND verified - allow access
  return children;
};
```

**Multi-Layer Protection:**
1. Not logged in ‚Üí redirect to `/`
2. Logged in but not verified ‚Üí redirect to `/verify-email`
3. Logged in AND verified ‚Üí allow access

---

### Complete User Flows

#### **Flow 1: New User Registration**
1. User fills signup form ‚Üí clicks "Sign Up"
2. Backend creates user with `email_verified: false`
3. Backend sends verification email with code
4. Frontend does NOT log user in (no token stored)
5. Frontend redirects to `/verify-email`
6. User enters code ‚Üí verified ‚Üí auto-login ‚Üí dashboard

#### **Flow 2: Unverified User Tries to Login**
1. User enters credentials ‚Üí clicks "Login"
2. Backend validates password ‚úÖ
3. Backend detects `email_verified: false`
4. Backend generates NEW code and sends fresh email
5. Backend returns response with `email_verified: false`
6. Frontend does NOT store token
7. Frontend shows toast: "New code sent"
8. Frontend redirects to `/verify-email`
9. User enters fresh code ‚Üí verified ‚Üí auto-login ‚Üí dashboard

#### **Flow 3: Unverified User Tries to Access Protected Route**
1. User manually navigates to `/dashboard`
2. ProtectedRoute checks user state
3. User not in state (no token stored)
4. Redirects to `/` (landing page)

#### **Flow 4: Somehow User Has Token But Not Verified (Edge Case)**
1. User has old token in localStorage
2. User navigates to `/dashboard`
3. ProtectedRoute checks `user.email_verified`
4. Detects `false` ‚Üí redirects to `/verify-email`
5. User must verify to proceed

#### **Flow 5: Google Sign-In (Pre-Verified)**
1. User clicks "Sign in with Google"
2. Backend receives Google token
3. Backend sets `email_verified: true` automatically
4. Frontend stores token
5. Frontend sets user
6. Redirects to dashboard immediately ‚úÖ

#### **Flow 6: Password User Links Google Account**
1. User registered with password (unverified)
2. User tries Google sign-in with same email
3. Backend finds existing user by email
4. Backend links Google account
5. Backend sets `email_verified: true` (Google verified)
6. Backend clears verification tokens
7. User now fully verified and logged in ‚úÖ

---

### Security Benefits

1. **Zero Unverified Access**: Impossible to access app without verification
2. **Fresh Codes**: New code sent on every login attempt (prevents stale codes)
3. **Multi-Layer Protection**:
   - Backend middleware blocks API calls
   - Frontend ProtectedRoute blocks navigation
   - AuthContext blocks state management
   - AuthService blocks token storage
4. **Unique Email Enforcement**: One email = one account (prevents duplicates)
5. **Google Auto-Verification**: Seamless for Google users
6. **Account Linking**: Password users can upgrade to Google (auto-verified)

---

### Testing Checklist

#### Registration Flow
- [x] Signup does not auto-login
- [x] User redirected to verification page
- [x] No token stored in localStorage
- [x] User not in AuthContext state
- [x] Verification email sent with code

#### Unverified Login Flow
- [x] Login validates credentials
- [x] NEW code generated and sent
- [x] User redirected to verification page
- [x] Toast shows "New code sent"
- [x] No token stored until verified

#### Protected Route Access
- [x] Dashboard blocked for unverified
- [x] Upload resume blocked
- [x] Projects blocked
- [x] Profile blocked
- [x] All API calls return 403 Forbidden

#### Google Authentication
- [x] Google sign-in auto-verifies
- [x] Direct access to dashboard
- [x] No verification screen
- [x] Token stored immediately

#### Account Linking
- [x] Password user can link Google
- [x] Auto-verifies on linking
- [x] Clears pending verification tokens
- [x] No duplicate accounts created

#### Unique Email Enforcement
- [x] Cannot create duplicate emails via password
- [x] Cannot create duplicate emails via Google
- [x] Different Google IDs with same email rejected
- [x] Linking works for same email different auth methods

---

## 11. Email Validation Regex Enhancement

### Issue
Email regex was too lenient - allowed TLDs with only 1 character or numbers.

### Solution
Updated email validation regex to require:
- At least 2 alphabetic characters after the dot (TLD)
- No numbers allowed in TLD

**Files Modified:**
- `frontend/src/components/auth/LoginForm.jsx` (line 40)
- `frontend/src/components/auth/SignupForm.jsx` (line 44)

**New Regex:**
```javascript
const emailRegex = /^[^\s@]+@[^\s@]+\.[a-zA-Z]{2,}$/;
```

**What it validates:**
- ‚úÖ Valid: `user@example.com`, `test@domain.co`, `name@site.org`
- ‚ùå Invalid: `user@example.c` (only 1 char), `test@domain.c0m` (number in TLD)

---

## 12. UserResponse Schema - Added email_verified Field

### Issue
**CRITICAL BUG**: Frontend couldn't check `email_verified` status because `UserResponse` schema didn't include it!

**Result:**
- Backend sent verification email ‚úÖ
- Backend returned `email_verified: false` ‚ùå (field missing from response)
- Frontend couldn't detect unverified status
- User shown "Failed to login" error instead of redirect to verification

### Solution
Added `email_verified` field to `UserResponse` schema.

**File: `backend/schemas/user.py`** (lines 24-38)

**Updated Schema:**
```python
class UserResponse(BaseModel):
    """Schema for user response"""
    id: int
    email: str
    full_name: str
    profile_picture_url: Optional[str] = None
    credits: float = 100.0
    base_resume_id: Optional[int] = None
    email_verified: bool = False  # ‚úÖ ADDED - Email verification status
    created_at: datetime
    last_login: Optional[datetime] = None
    google_id: Optional[str] = None  # ‚úÖ ADDED - For account linking

    class Config:
        from_attributes = True
```

**Impact:**
- Frontend can now check `response.user.email_verified`
- Login correctly detects unverified users
- Redirects to verification page with toast message
- Bug fixed! ‚úÖ

---

## 13. Cleanup Job for Unverified Users (30 Days)

### Implementation
Created automated cleanup job to delete unverified user accounts after 30 days.

**File Created: `backend/jobs/cleanup_unverified_users.py`**

**What it does:**
1. Finds users where `email_verified = False`
2. Checks if account created more than 30 days ago
3. Deletes those accounts from database
4. Logs all deletions for audit trail

**Key Features:**
```python
def cleanup_unverified_users():
    """Delete unverified users older than 30 days"""
    db = SessionLocal()
    try:
        # Calculate cutoff date (30 days ago)
        cutoff_date = datetime.now(timezone.utc) - timedelta(days=30)

        # Find and delete unverified users older than cutoff
        deleted_count = db.query(User).filter(
            and_(
                User.email_verified == False,
                User.created_at < cutoff_date
            )
        ).delete(synchronize_session=False)

        db.commit()
        logger.info(f"‚úÖ Successfully deleted {deleted_count} unverified users")
        return deleted_count

    except Exception as e:
        db.rollback()
        logger.error(f"‚ùå Failed to cleanup unverified users: {e}")
        raise
    finally:
        db.close()
```

**Safety Features:**
- Only deletes unverified users (verified users never touched)
- 30-day grace period (ample time to verify)
- Transaction safety with rollback on error
- Comprehensive logging for audit trail
- Can be tested manually before scheduling

**Documentation Created: `backend/jobs/README.md`**

Includes instructions for:
- Manual testing
- Cron job setup (production)
- APScheduler integration (development)
- systemd timer (Linux production)
- Monitoring and troubleshooting
- Configuration changes

**How to Run:**

**Manual Testing:**
```bash
cd backend
python -m jobs.cleanup_unverified_users
```

**Cron Job (Production):**
```bash
# Run daily at 3 AM
0 3 * * * cd /path/to/backend && /path/to/venv/bin/python -m jobs.cleanup_unverified_users >> /var/log/cleanup_users.log 2>&1
```

**APScheduler (Recommended for Development):**
```python
# Add to main.py lifespan
from apscheduler.schedulers.background import BackgroundScheduler
from jobs.cleanup_unverified_users import run_cleanup_job

scheduler = BackgroundScheduler()
scheduler.add_job(
    run_cleanup_job,
    'cron',
    hour=3,
    minute=0,
    id='cleanup_unverified_users'
)
scheduler.start()
```

**Benefits:**
- Prevents database bloat from fake emails
- Removes abandoned signups automatically
- Handles typos in email addresses
- Minimal maintenance required
- Industry-standard approach

---

*Session completed on November 29, 2025*
